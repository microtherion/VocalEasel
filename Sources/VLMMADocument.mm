//
// File: VLMMADocument.mm - Export document in MMA format
//
// Author(s):
//
//      (MN)    Matthias Neeracher
//
// Copyright © 2006-2007 Matthias Neeracher
//

#import "VLMMADocument.h"
#import "VLMMAWriter.h"

@implementation VLDocument (MMA)

- (NSData *)mmaDataWithError:(NSError **)outError
{
	char		buf[32];
	NSBundle *	bndl = [NSBundle mainBundle];
	VLMMAWriter	writer(playElements & kVLPlayGroovePreview, 
					   previewRange.location, 
					   previewRange.location+previewRange.length);

	writer.Visit(*song);
	std::string	mmaFile = std::string("// Generated by VocalEasel ")
		+ (const char *)[[bndl objectForInfoDictionaryKey:@"CFBundleVersion"]
							UTF8String]
		+ "\n\n";
	sprintf(buf, "Tempo %ld\n", lround(songTempo));
	mmaFile	+= buf;
	if (playElements & kVLPlayGroovePreview) {
		//
		// Override all other flags
		//
		mmaFile += "Groove ";
		mmaFile += [songGroove UTF8String];
		mmaFile += "\nSolo Off\n";
	} else {
		if (playElements & kVLPlayCountIn)
			switch ([[self songTime] intValue]) {
			case 0x404:
				mmaFile	+= "Groove Metronome2-4\nz\nz\n";
				break;
			case 0x304:
			case 0x608:
				mmaFile	+= "Groove Metronome3\nz\nz\n";
				break;
			default:
				// Can't handle these yet
				break;
			}
        mmaFile += "Solo Voice AltoSax\nSolo Volume fff\n";
	}
	mmaFile += '\n'+writer.Measures();	

	return [[NSString stringWithUTF8String:mmaFile.c_str()] 
			   dataUsingEncoding:NSUTF8StringEncoding];
}

- (NSFileWrapper *)mmaFileWrapperWithError:(NSError **)outError
{
	NSData * data = [self mmaDataWithError:outError];
	
	if (!data)
		return nil;
	else
		return [[[NSFileWrapper alloc] 
					initRegularFileWithContents:data]
				   autorelease];
}

@end
