//
//  VLLilypondDocument.mm
//  Vocalese
//
//  Created by Matthias Neeracher on 10/20/06.
//  Copyright 2006 __MyCompanyName__. All rights reserved.
//

#import "VLMMADocument.h"

@implementation VLDocument (MMA)

const int kMajorOffset 	= 6;
const int kMinorOffset  = 9;

const char * sKeyNames[] = {
	"ges", "des", "as", "es", "bes", "f",
	"c", "g", "d", "a", "e", "b", "fis", "cis", "gis"
};

- (NSData *)mmaDataWithError:(NSError **)outError
{
	char	buf[32];
	NSBundle *	 			bndl = [NSBundle mainBundle];
	const VLProperties & 	prop = song->fProperties.front();

	std::string	mmaFile = std::string("// Generated by VocalEasel ")
		+ (const char *)[[bndl objectForInfoDictionaryKey:@"CFBundleVersion"]
							UTF8String]
		+ "\n\n";
	sprintf(buf, "Tempo %d\n", [songTempo intValue]);
	mmaFile	+= buf;
	sprintf(buf, "Groove %s\n", [songGroove UTF8String]);
	mmaFile	+= buf;
	sprintf(buf, "KeySig %d%c\n", labs(prop.fKey), prop.fKey>=0 ? '#' : '&');
	mmaFile	+= buf;
	mmaFile += '\n';
	
	std::string			mmas;
	for (size_t m=0; m<song->CountMeasures(); ++m) {
		sprintf(buf, "%-5d", m+1);
		mmaFile += buf;
		song->fMeasures[m].MMAChords(mmas);
		mmaFile += mmas;
		song->fMeasures[m].MMANotes(mmas);
		mmaFile += "\t{ " + mmas + " }\n";
	}
	mmaFile	+= mmas;

	return [[NSString stringWithUTF8String:mmaFile.c_str()] 
			   dataUsingEncoding:NSUTF8StringEncoding];
}

- (NSFileWrapper *)mmaFileWrapperWithError:(NSError **)outError
{
	NSData * data = [self mmaDataWithError:outError];
	
	if (!data)
		return nil;
	else
		return [[[NSFileWrapper alloc] 
					initRegularFileWithContents:data]
				   autorelease];
}

@end
