#!/usr/bin/ruby
#
# VLLilypondType.reader - Import lilypond files
#

DEBUG = false

require File.dirname($0)+'/plistWriter'
require File.dirname($0)+'/vl'

OUTPUT = {'measures' => []}

#
# Lex
#
tokens = []
$stdin.each do |line|
  line.chomp!.sub!(/%.*/, "")
  line.scan(/\G\s*(\{|\}|\(|\)|\||=|~|<<|>>|#'|#\(|##t|##f|\\\w+|\".*?\"|[-+\w\d.',:]+|.)/) do |token|
    tokens.push(token[0])
  end
end
#
# Parse
#
nestLevel = 0
block     = nil
level     = -1
stack     = []
chords    = []
notes     = []
lyrics    = []
lastDur   = 1
divisions = 2
tied      = false
timeNum   = 4
timeDenom = 4
key       = 0
mode      = 'minor'

$RELPITCH = 0

PITCH = {
  ?c => 0,
  ?d => 2,
  ?e => 4,
  ?f => 5,
  ?g => 7,
  ?a => 9,
  ?b => 11
}

def lyPitch(pitch, base=-1)
  if !pitch || pitch =~ /[rs]/
    return VL::NoPitch
  end
  p = PITCH[pitch[0]] || 0
  if base > -1
    p += base
  elsif $RELPITCH > 0
    while $RELPITCH-p > 5
      p += 12
    end
    $RELPITCH = p
  else
    p += 60
  end
  pitch.scan(/'/) {|c| p += 12}
  pitch.scan(/,/) {|c| p -= 12}
  if pitch =~ /^[ea]s/
    p -= 1
    pitch[0..1] = ""
  end
  pitch.scan('is') { |x| p += 1 }
  pitch.scan('es') { |x| p -= 1 }

  return p
end

def lyDur(dur)
  dur =~ /^(\d+)(?:\*(\d+).(\d+))?/
  num = 1
  den = $1.to_i
  if $2 
    num *= $2.to_i
    den *= $3.to_i
  end
  return [num,den]
end

STEPS = {
  ''     => VL::Chord::Maj,
  'm'    => VL::Chord::Min,
  'maj'  => VL::Chord::Maj7, 
  'dim7' => VL::Chord::Dim7,
  'dim'  => VL::Chord::Dim,
  'aug'  => VL::Chord::Aug,
  'sus4' => VL::Chord::Sus4,
  'sus2' => VL::Chord::Sus2,
  'sus'  => VL::Chord::Sus4
}

DEGREE = [
  [VL::Unison, VL::Unison],
  [VL::Min2nd+VL::Maj2nd, VL::Maj2nd],
  [VL::Min3rd+VL::Maj3rd, VL::Maj3rd],
  [VL::Fourth, VL::Fourth],
  [VL::Fifth, VL::Fifth],
  [VL::Aug5th+VL::Dim7th, VL::Dim7th],
  [VL::Min7th+VL::Maj7th, VL::Min7th],
  [VL::Octave, VL::Octave],
  [VL::Min9th+VL::Maj9th, VL::Maj9th],
  [VL::Aug9th+VL::Dim11th, VL::Dim11th],
  [VL::Eleventh, VL::Eleventh],
  [VL::Aug11th+VL::Dim13th, VL::Dim13th],
  [VL::Min13th+VL::Maj13th, VL::Maj13th]
];

MAJORKEY = [
  0,  # C 
  -5, # Db
  2,  # D
  -3, # Eb
  4,  # E
  -1, # F
  -6, # Gb
  1,  # G
  -4, # Ab
  3,  # A
  -2, # Bb
  5,  # B
];

MINORKEY = [
  -3, # Cm  -> Eb
  4,  # Dbm -> E
  -1, # Dm  -> F
  -6, # Ebm -> Gb
  1,  # Em  -> G
  -4, # Fm  -> Ab
  3,  # F#m -> A
  -2, # Gm  -> Bb
  5,  # G#m -> B
  0,  # Am  -> C 
  -5, # Bbm -> Db
  2,  # Bm  -> D
];

def lySteps(steps)
  steps =~ /^(|m|maj|dim7?|aug|sus[42]?)/
  s     = STEPS[$1]
  steps = $'
  if !($1 =~ /\d/) && steps =~ /^(7|9|11|13)/
    if !(s & VL::Maj7th)
      s |= VL::Min7th
    end
    case $1
    when '9'
      s |= VL::Maj9th
    when '11'
      s |= VL::Maj9th+VL::Maj11th
    when '13'
      s |= VL::Maj9th+VL::Maj11th+VL::Maj13th
    end
    steps = $'
  end
  steps.scan(/(\^)?(\d+)([-+])?/) do |ext|
    degree = DEGREE[$2.to_i-1]
    if $1 == '^'
      s &= ~degree[0]
    else
      step = degree[1]
      if $3 == '+'
        step <<= 1
      elsif $3 == '-'
        step >>= 1
      end
      s = (s & ~degree[0]) | step
    end
  end
  return s
end

while tokens.length > 0
  # puts "#{tokens.length}:#{nestLevel}[#{block}] #{tokens[0]} #{tokens[1]} #{tokens[2]}"
  token = tokens.shift
  #
  # Title, composer, etc.
  #
  if tokens[0] == '='
    case token
    when 'title','composer','poet'
      key   = token=='poet' ? 'lyricist' : token
      value = tokens[1]
      value.sub!(/"(.*)"/, '\1')
    
      OUTPUT[key] = value
      tokens[0..1]= nil

      redo
    end
  end

  case block
  when '\header', '\paper'
    # Ignore 
  when '\chords', '\chordmode'
    #
    # Possibly chords
    #
    if token.downcase =~ %r{^
                             ([rs] |             # Rest
                              [a-g](?:[ei]?s)?   # g, ges, fis, es, as 
                             ) 
                             (\d+                # 1, 2, 4, 8, 16 ...
                              (?:\*\d+/\d+)?     # *3/4
                             )? 
                             (?:\:([-+^:.a-z\d]+))? # :maj9.7-^2
                             (?:/\+(             # /+
                              [a-g](?:[ei]?s)?   # Root: a, bes, fis, as
                             ))? 
                          $}x
      pitch   = lyPitch($1, 60)
      dur     = $2 || lastDur
      ext     = $3 ? lySteps($3) : 0
      root    = lyPitch($4, 48)
      lastDur = dur
      d       = lyDur(dur)

      chord = {'pitch' => pitch, 'root' => root, 'steps' => ext,
               'durNum'=> d[0], 'durDenom' => d[1]}
      p token, chord if DEBUG
      chords.push(chord)
      redo
    end
  when 'voice'
    #
    # Possibly notes
    #
    if token.downcase =~ %r{^
                             ([rs] |             # Rest
                              [a-g](?:[ei]?s)?   # g, ges, fis, es, as 
                              [',]*              # g'''
                             ) 
                             (\d+                # 1, 2, 4, 8, 16 ...
                              (?:\*\d+/\d+)?     # *3/4
                             )? 
                          $}x
      pitch   = lyPitch($1, 60)
      dur     = $2 || lastDur
      lastDur = dur
      d       = lyDur(dur)

      note = {'pitch' => pitch, 'durNum'=> d[0], 'durDenom' => d[1]}
      note['tied'] = VL::TiedWithPrev if tied
      p token, note if DEBUG
      notes.push(note)
      tied = false
      redo
    elsif token == '~' 
      if note = notes.last
        note['tied'] ||= 0
        note['tied'] |= VL::TiedWithNext
      end
      tied = true
    end
  end

  #
  # Nesting levels
  #
  case token
  when '{', '<<'
    nestLevel += 1
  when '}', '>>'
    nestLevel -= 1
    if nestLevel <= level
      if lv = stack.pop
        block = lv[0]
        level = lv[1]
      else
        block = nil
        level = -1
      end
    end
  when '\chords', '\header', '\paper'
    block = token
    level = nestLevel
  when '\chordmode'
    block = '\chords'
    level = nestLevel
  when '\relative'
    $RELPITCH = 60
    block     = 'voice'
    level     = nestLevel
  when '\time'
    if tokens[0] =~ %r{(\d+)/(\d+)}
      timeNum   = $1
      timeDenom = $2
      tokens[0..0] = nil
    end
    if block != 'voice'
      block     = 'voice'
      level     = nestLevel-1
    end
  when '\key'
    p    = lyPitch(tokens[0], 0)
    mode = tokens[1]
    key  = mode == '\minor' ? MINORKEY[p] : MAJORKEY[p]
    tokens[0..1] = nil
    if block != 'voice'
      block     = 'voice'
      level     = nestLevel-1
    end
  end
end

OUTPUT['properties'] = [{
  'divisions' => divisions,
  'key'       => key,
  'mode'      => mode == '\minor' ? -1 : 1,
  'timeNum'   => timeNum,
  'timeDenom' => timeDenom
}]                          

writePlist($stdout, OUTPUT)

# Local Variables:
# mode:ruby
# End:
