#!/usr/bin/ruby
#
# VLMusicXMLType.write - Translate plist into MusicXML
#

require File.dirname($0)+'/plistReader'
require File.dirname($0)+'/vl'
require 'rexml/document'

INPUT = readPlist(INFILE)

$USE_FLATS = false
$DIVISIONS = 3

def newTextElement(name, text)
  elt = REXML::Element.new(name)
  elt.add_text(text.to_s)

  return elt
end

def _work
  work = REXML::Element.new('work')
  work.add_element newTextElement('work-title', INPUT['title'])

  return work
end

def _identification
  ident = REXML::Element.new('identification')
    composer = newTextElement('creator', INPUT['composer'])
    composer.add_attribute('type', 'composer')
  ident.add_element(composer)
    poet = newTextElement('creator', INPUT['lyricist'])
    poet.add_attribute('type', 'lyricist')
  ident.add_element(poet)
    encoding = REXML::Element.new('encoding')
    if INPUT['saved']
      date = newTextElement('encoding-date', INPUT['saved'].strftime("%Y-%m-%d")) 
      encoding.add_element(date)
    end
    if INPUT['software']
      software = newTextElement('software', INPUT['software']) if INPUT['software']
      encoding.add_element(software)
    end
  ident.add_element(encoding)

  return ident
end

def _part_list
  part_list = REXML::Element.new('part-list')
    melody = REXML::Element.new('score-part')
    melody.add_attribute('id', 'MELO')
    melody.add_element newTextElement('part-name', 'Song')
  part_list.add_element(melody)

  return part_list
end

def _attributes(prop)
  $USE_FLATS = prop['key'] < 0
  $DIVISIONS = prop['divisions']
  attr = REXML::Element.new('attributes')
  attr.add_element newTextElement('divisions', prop['divisions'])
    key = REXML::Element.new('key')
    key.add_element newTextElement('fifths', prop['key'])
    key.add_element newTextElement('mode', prop['mode'] > 0 ? "major" : "minor")
  attr.add_element(key)
    time = REXML::Element.new('time')
    time.add_element newTextElement('beats', prop['timeNum'])
    time.add_element newTextElement('beat-type', prop['timeDenom'])
  attr.add_element(time)
    clef = REXML::Element.new('clef')
    clef.add_element newTextElement('sign', 'G')
    clef.add_element newTextElement('line', 2)
  attr.add_element(clef)

  return attr
end

def _groove(groove)
  dir = REXML::Element.new('direction')
    dty = REXML::Element.new('direction-type')
    dty.add_element newTextElement('words', groove)
  dir.add_element(dty)

  return dir
end

def _tempo(tempo)
  dir = REXML::Element.new('direction')
    dty = REXML::Element.new('direction-type')
      metro = REXML::Element.new('metronome')
      metro.add_element newTextElement('beat-unit', 'quarter')
      metro.add_element newTextElement('per-minute', tempo)
    dty.add_element(metro)
  dir.add_element(dty)
  dir.add_element 'sound', {'tempo' => tempo}

  return dir
end

STEPS = 'C DbD EbE F GbG AbA BbB '

def _pitch(name, pitch, prefix="")
  oct  = pitch/12 - 1
  stp  = 2*(pitch%12)
  step = STEPS[stp]
  alt  = STEPS[stp+1] == ?b
  if alt
    if $USE_FLATS
      alt = -1
    else
      step = step == ?A ? ?G : step-1
      alt  = 1
    end
  end
  if prefix.length > 0
    prefix += "-"
  end
  pitch= REXML::Element.new(name)
  pitch.add_element newTextElement(prefix+'step', step.chr)
  if alt
    pitch.add_element newTextElement(prefix+'alter', alt)
  end
  if prefix.length == 0
    pitch.add_element newTextElement('octave', oct)
  end

  return pitch
end

TYPE = %w[whole half quarter eighth 16th 32nd]

def _note(pitch, dur, visual, tied)
  note = REXML::Element.new('note')
  if pitch == VL::NoPitch
    note.add_element(REXML::Element.new('rest'))
  else
    if (tied & VL::InChord) != 0
      note.add_element 'chord'
    end
    note.add_element(_pitch('pitch', pitch))
  end
  note.add_element newTextElement('duration', dur)
  if (tied & VL::TiedWithPrev) != 0
    note.add_element 'tie', {'type' => 'stop' }
  end
  if (tied & VL::TiedWithNext) != 0
    note.add_element 'tie', {'type' => 'start' }
  end
  note.add_element newTextElement('voice', 1)
  note.add_element newTextElement('type', TYPE[visual & 7]) 

  return note
end

CHORD = {
  #
  # Triads
  #
  'major'              => VL::Chord::Maj,
  'minor'              => VL::Chord::Min,
  'augmented'          => VL::Chord::Aug,
  'diminished'         => VL::Chord::Dim,
  #
  # 7ths
  #
  'dominant'           => VL::Chord::Dom7,
  'major-seventh'      => VL::Chord::Maj7,
  'minor-seventh'      => VL::Chord::Min7,
  'diminished-seventh' => VL::Chord::Dim7,
  'augmented-seventh'  => VL::Chord::Aug7,
  'half-diminished'    => VL::Chord::M7b5,
  'major-minor'        => VL::Chord::MMin7,
  #
  # 6ths
  #
  'major-sixth'        => VL::Chord::Maj6,
  'minor-sixth'        => VL::Chord::Min6,
  #
  # 9ths
  #
  'dominant-ninth'     => VL::Chord::Dom9,
  'major-ninth'        => VL::Chord::Maj9,
  'minor-ninth'        => VL::Chord::Min9,
  #
  # 11ths
  #
  'dominant-11th'      => VL::Chord::Dom11,
  'major-11th'         => VL::Chord::Maj11,
  'minor-11th'         => VL::Chord::Min11,
  #
  # 13ths
  #
  'dominant-13th'      => VL::Chord::Dom13,
  'major-13th'         => VL::Chord::Maj13,
  'minor-13th'         => VL::Chord::Min13,
  #
  # Suspended
  #
  'suspended-second'   => VL::Chord::Sus2,
  'suspended-fourth'   => VL::Chord::Sus4,
  #
  # Varia
  #
  'other'              => VL::Unison,
  'none'               => 0
}

#
# This list differs a bit from the list in .reader, as we prefer 
# certain degrees, i.e. #9 rather than b10
#
DEGREE = [
  [VL::Unison, VL::Unison],
  [VL::Min2nd+VL::Maj2nd, VL::Maj2nd],
  [VL::Min3rd+VL::Maj3rd, VL::Maj3rd],
  [VL::Fourth, VL::Fourth],
  [VL::Dim5th+VL::Fifth+VL::Aug5th, VL::Fifth],
  [VL::Dim7th, VL::Dim7th],
  [VL::Min7th+VL::Maj7th, VL::Min7th],
  [VL::Octave, VL::Octave],
  [VL::Min9th+VL::Maj9th+VL::Aug9th, VL::Maj9th],
  [0, VL::Dim11th],
  [VL::Dim11th+VL::Eleventh+VL::Aug11th, VL::Eleventh],
  [0, VL::Dim13th],
  [VL::Dim13th+VL::Min13th+VL::Maj13th, VL::Maj13th]
];

def _chord(pitch, steps, root)
  #
  # Pick kind. sus takes precedence
  #
  if (steps & (VL::Min3rd|VL::Maj3rd)) == 0 and (steps & (VL::Maj2nd|VL::Fourth))!= 0
    if (steps & VL::Fourth) != 0
      kind = 'suspended-fourth'
    else
      kind = 'suspended-second'
    end
  else
    #
    # It's hard to score alterations properly, so rank purely by correct steps
    #
    best = 0
    kind = 'none'
    CHORD.each do |k,mask|
      extra = mask & ~steps
      mask &= steps
      score = 0
      while mask > 0
        score += 10
        mask  &= mask-1
      end
      while extra > 0
        score -= 1
        extra &= extra-1
      end
      if score > best
        kind = k
        best = score
      end
    end
  end
  harm = REXML::Element.new('harmony')
  harm.add_element(_pitch('root', pitch, 'root'))
  harm.add_element newTextElement('kind', kind)
  if root != VL::NoPitch
    harm.add_element(_pitch('bass', root, 'bass'))
  end
  needSteps = steps & ~CHORD[kind]
  extraSteps= CHORD[kind] & ~steps
  if (needSteps+extraSteps) > 0
    DEGREE.each_index do |deg|
      mask = DEGREE[deg][0]
      type = nil
      need = needSteps & mask
      extra= extraSteps & mask
      if need != 0
        if extra != 0
          type = 'alter'
          alter= extra > need ? -1 : 1
        else
          type = 'add'
          step = DEGREE[deg][1]
          alter= step > need ? -1 : (step < need ? 1 : 0)
        end
      elsif extra != 0
        type = 'subtract'
        alter= 0
      end
      if type
        degree = REXML::Element.new('degree')
        degree.add_element newTextElement('degree-value', (deg+1).to_s)
        degree.add_element newTextElement('degree-alter', alter.to_s)
        degree.add_element newTextElement('degree-type', type)
        harm.add_element(degree)

        needSteps  &= ~need
        extraSteps &= ~extra
        
        break if (needSteps+extraSteps) == 0
      end
    end
  end

  return harm
end

SYLLABLE = %w[single begin end middle]

def _melody
  melody = REXML::Element.new('part')
  melody.add_attribute('id', 'MELO')
  
  lastProp   = -1
  lastGroove = nil
  measNum    = 0
  repeat     = [0]
  INPUT['measures'].each do |meas|
    r = 0
    r |= 1 if meas['begin-repeat']
    r |= 2 if meas['end-repeat']
    repeat.push r
  end
  repeat.push 0
  INPUT['measures'].each do |meas|
    measNum += 1
    m = REXML::Element.new('measure')
    m.add_attribute('number', measNum.to_s);
    if measNum == 1
      m.add_element(_tempo(INPUT['tempo'].to_i))
    end
    if meas['properties'] != lastProp
      lastProp = meas['properties']
      groove   = INPUT['properties'][lastProp]['groove']
      if groove != lastGroove
        lastGroove = groove
        m.add_element(_groove(lastGroove))
      end
      m.add_element(_attributes(INPUT['properties'][lastProp]))
    end
    if meas['new-page']
      m.add_element 'print', {'new-page' => 'yes'}
    elsif meas['new-system']
      m.add_element 'print', {'new-system' => 'yes'}
    end
    if meas['coda']
      m.add_element 'sound', {'coda' => 'A'}
    end
    if meas['begin-repeat']
      barline = REXML::Element.new('barline')
      barline.add_attribute('location', 'left')
      barline.add_element newTextElement('bar-style', 
                 (repeat[measNum-1] & 2) != 0 ? 'heavy-heavy' : 'heavy-light')
      barline.add_element 'repeat', {'direction' => 'forward'}
      m.add_element(barline)
    end
    if ending = meas['begin-ending']
      barline = REXML::Element.new('barline')
      barline.add_attribute('location', 'left')
      volta = ending['volta']
      num   = nil
      (0..7).each do |i|
        if (volta & (1<<i)) != 0
          if num
            num += ",#{i+1}"
          else
            num = (i+1).to_s
          end
        end
      end
      barline.add_element 'ending', {'type' => 'start', 'number' => num}
      m.add_element(barline)
    end
    noteAt = 0
    chordAt= 0
    chords = meas['chords']
    chordIx= 0
    meas['melody'].each do |note|
      dur = (note['durNum'] * $DIVISIONS * 4) / note['durDenom']
      tempAt = noteAt
      while chordIx < chords.length && chordAt < noteAt+dur
        chord = chords[chordIx]
        if chord['pitch'] != VL::NoPitch
          if chordAt > tempAt
            fw = REXML::Element.new('forward')
            fw.add_element newTextElement('duration', (chordAt-tempAt).to_s)
            m.add_element(fw)
            tempAt = chordAt
          end
          m.add_element(_chord(chord['pitch'], chord['steps'], chord['root']))
        end
        chordAt += (chord['durNum'] * $DIVISIONS * 4) / chord['durDenom']
        chordIx += 1
      end
      if tempAt > noteAt
        bk = REXML::Element.new('backup')
        bk.add_element newTextElement('duration', (tempAt-noteAt).to_s)
        m.add_element(bk)
        tempAt = noteAt        
      end
      n   = _note(note['pitch'], dur, note['visual'], note['tied'] || 0)
      stanza = 1
      note['lyrics'].each do |syll|
        if syll['text']
          lyr = REXML::Element.new('lyric')
          lyr.add_attribute('number', stanza.to_s)
          lyr.add_element newTextElement('syllabic', SYLLABLE[syll['kind']])
          lyr.add_element newTextElement('text', syll['text'])
          n.add_element(lyr)
        end
        stanza += 1
      end if note['lyrics']
      noteAt += dur
      m.add_element(n)
    end
    if r = meas['end-repeat']
      barline = REXML::Element.new('barline')
      barline.add_attribute('location', 'right')
      barline.add_element newTextElement('bar-style', 
                 (repeat[measNum+1] & 1) != 0 ? 'heavy-heavy' : 'light-heavy')
      barline.add_element 'repeat', {'direction' => 'backward', 'times' => r['times'].to_s}
      m.add_element(barline)      
    end
    if ending = meas['end-ending']
      barline = REXML::Element.new('barline')
      barline.add_attribute('location', 'right')
      barline.add_element newTextElement('bar-style', 
                 (repeat[measNum+1] & 1) != 0 ? 'heavy-heavy' : 'light-heavy')
      volta = ending['volta']
      num   = nil
      (0..7).each do |i|
        if (volta & (1<<i)) != 0
          if num
            num += ",#{i+1}"
          else
            num = (i+1).to_s
          end
        end
      end
      type = ending['last'] ? "discontinue" : "stop"
      barline.add_element 'ending', {'type', type, 'number', num}
      barline.add_element 'repeat', {'direction' => 'backward'}
      m.add_element(barline)      
    end
    if meas['tocoda']
      m.add_element 'sound', {'tocoda' => 'A'}
    end
    melody.add_element(m)
  end

  return melody
end

def _score  
  score = REXML::Element.new('score-partwise')
  score.add_attribute('version', '1.1')
  score.add_element(_work)
  score.add_element(_identification)
  score.add_element(_part_list)
  score.add_element(_melody)

  return score
end

NEW_REXML = REXML::VERSION > "3.1.7"

xml  = REXML::Document.new 
xml.add REXML::XMLDecl.new('1.0', 'UTF-8')
xml.add REXML::DocType.new(['score-partwise', 'PUBLIC',
	 '"-//Recordare//DTD MusicXML 1.1 Partwise//EN"',
         NEW_REXML ? 'http://www.musicxml.org/dtds/partwise.dtd' :
	             '"http://www.musicxml.org/dtds/partwise.dtd"'])
xml.add_element(_score)
if NEW_REXML
  formatter = REXML::Formatters::Pretty.new(2)
  formatter.compact = true
  formatter.write(xml, $stdout)
else
  xml.write($stdout, 0)
end

# Local Variables:
# mode:ruby
# End:
