#!/usr/bin/ruby
#
# VLMusicXMLType.reader - Create plist from MusicXML
#

require File.dirname($0)+'/plistWriter'
require File.dirname($0)+'/vl'
require 'rexml/document'
require 'rexml/streamlistener'
require 'time'

OUTPUT = {'measures' => []}

PITCH = {
  'C' => 0,
  'D' => 2,
  'E' => 4,
  'F' => 5,
  'G' => 7,
  'A' => 9,
  'B' => 11
}

SYLL = {
  'single' => 0,
  'begin'  => 1,
  'end'    => 2,
  'middle' => 3
}

class MusicXMLListener
  include REXML::StreamListener

  def initialize
    @text = ""
  end

  def tag_start(tag, attrs)
    @kind = nil  # Ignore all tags not recognized here
    @text = ""
    case tag
    when 'score-timewise' then
      $stderr.puts "Can't read timewise MusicXML files yet"
      exit 1
    when 'work-title' then
      @kind = 'textProp'
      @key  = 'title'
    when 'creator' then
      case attrs['type']
      when 'composer' then
        @kind = 'textProp'
        @key  = 'composer'
      when 'poet' then
        @kind = 'textProp'
        @key  = 'lyricist'
      end
    when 'miscellaneous-field' then
      if attrs['name'] == 'VocalEasel-groove'
        @kind = 'textProp'
        @key  = 'groove'
      end
    when 'encoding-date' then
      @kind = 'dateProp'
      @key  = 'saved'
    when 'software' then
      @kind = 'textProp'
      @key  = 'software'
    when 'part' then
      @part   = attrs['id'] || ""
      @prop   = {}
      @props  = []
      @measNo = -1
    when 'measure' then
      @notes= []
      @chord= false
      if a = attrs['number']
        @measNo = a.to_i-1
      else
        @measNo += 1
      end
      unless @meas = OUTPUT['measures'][@measNo] 
        @meas = OUTPUT['measures'][@measNo] = {
          'measure'    => @measNo,
          'properties' => 0,
          'chords'     => [],
          'melody'     => []
        }
      end
    when 'barline' then
      @times     = nil
      @type      = nil
      @number    = ""
    when 'repeat' then
      if attrs['direction'] == 'backward' && attrs['times']
        @times = attrs['times'].to_i
      elsif attrs['direction'] == 'forward'
        @times = 0
      end
    when 'ending' then
      @type      = attrs['type']
      @number    = attrs['number']
    when 'sound' then
      if attrs['tocoda']
        @meas['tocoda'] = true
      elsif attrs['coda']
        @meas['coda'] = true
      end
    when 'divisions' then
      @kind = 'prop'
      @key  = 'divisions'
    when 'fifths' then
      @kind = 'prop'
      @key  = 'key'
    when 'beats' then
      @kind = 'prop'
      @key  = 'timeNum'
    when 'beat-type' then
      @kind = 'prop'
      @key  = 'timeDenom'
    when 'note' then
      @note = { 'pitch' => 0, 'durNum' => 0, 'durDenom' => 0 }
    when 'rest' then
      @note['pitch'] = -128
    when 'mode', 'step', 'alter', 'octave', 'duration', 'syllabic', 'text' then
      @kind = tag
    when 'tie' then
      @note['tied'] ||= 0
      case attrs['type']
      when 'start' then
        @note['tied'] |= VL::TiedWithNext
      when 'stop' then
        @note['tied'] |= VL::TiedWithPrev
      end
    when 'lyric' then
      num = (attrs['number'] || "1").to_i-1
      @note['lyrics'] ||= []
      @note['lyrics'][num] = @lyric = {}
    when 'chord' then
      @chord = true
    end
  end

  def text(text)
    @text += text
  end

  def makeChords(chords)
    chords.each do |chord|
      chord['root'] = -128
      st = [*chord['pitch']].sort
      pitch = st[0] 
      if pitch > 0 && pitch < 60
        chord['root'] = st.shift
        pitch         = st[0] || -128
      end
      steps = 0
      if pitch > 0
        st.each do |step|
          steps |= 1<<(step-pitch)
        end
      end
      chord['steps'] = steps
      chord['pitch'] = pitch
    end

    return chords
  end

  def makeVolta(number)
    volta = 0
    number.split(/,\s*/).each do |v|
      volta |= 1<<(v.to_i-1)
    end

    return volta
  end

  def tag_end(tag)
    #
    # Interesting text nodes have @kind set
    #
    if @kind
      case @kind
      when 'textProp' then
        OUTPUT[@key] = @text
      when 'dateProp' then
        OUTPUT[@key] = Time.parse(@text)
      when 'prop' then
        @prop[@key] = @text.to_i
      when 'mode' then
        @prop['mode'] = @text == 'minor' ? -1 : 1
      when 'step' then
        @note['pitch'] += PITCH[@text]
      when 'alter' then
        @note['pitch'] += @text.to_i
      when 'octave' then
        @note['pitch'] += (@text.to_i+1)*12
      when 'duration' then
        @note['durNum']   = @text.to_i
        @note['durDenom'] = @prop['divisions']*4
      when 'syllabic' then
        @lyric['kind'] = SYLL[@text]
      when 'text' then
        @lyric['text'] = @text
      end
      @kind = nil
    else
      #
      # Structures are distinguished by tag
      #
      case tag
      when 'attributes' then
        if @prop != @props.last
          @props.push(@prop)
        end
      when 'note' then
        if @chord
          note = @notes.last
          note['pitch'] = [*note['pitch']] << @note['pitch']
          @chord = false
        else
          @notes.push(@note)
        end
      when 'barline' then
        case @type
        when 'start' then
          @meas['begin-ending'] = { 
            'volta' => makeVolta(@number)
          }
        when 'stop', 'discontinue' then
          @meas['end-ending'] = { 
            'volta' => makeVolta(@number),
            'last'  => @type == 'discontinue'
          }
        else
          if @times > 0
            @meas['end-repeat'] = {
              'times' => @times
            }
          elsif @times == 0
            @meas['begin-repeat'] = {}
          end
        end
      when 'measure' then
        @meas['properties'] = @props.length-1 unless @props.empty?
        if @part == 'HARM'
          @meas['chords'] = makeChords(@notes)
        else
          @meas['melody'] = @notes
        end
      when 'part' then
        OUTPUT['properties'] = @props unless @part == 'HARM'
      end
    end
  end
end

listener = MusicXMLListener.new
REXML::Document.parse_stream($stdin, listener)
writePlist($stdout, OUTPUT)

# Local Variables:
# mode:ruby
# End:
